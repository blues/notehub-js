/**
 * Notehub API
 * The OpenAPI definition for the Notehub.io API.
 *
 * The version of the OpenAPI document: 1.2.0
 * Contact: engineering@blues.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from "../ApiClient";
import CreateUpdateRepository from "../model/CreateUpdateRepository";
import DataSet from "../model/DataSet";
import Error from "../model/Error";
import Repository from "../model/Repository";

/**
 * Repository service.
 * @module api/RepositoryApi
 * @version 1.0.28
 */
export default class RepositoryApi {
  /**
   * Constructs a new RepositoryApi.
   * @alias module:api/RepositoryApi
   * @class
   * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
   * default to {@link module:ApiClient#instance} if unspecified.
   */
  constructor(apiClient) {
    this.apiClient = apiClient || ApiClient.instance;
  }

  /**
   * Create a new repository
   * @param {module:model/CreateUpdateRepository} createUpdateRepository
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Repository} and HTTP response
   */
  createRepositoryWithHttpInfo(createUpdateRepository) {
    let postBody = createUpdateRepository;
    // verify the required parameter 'createUpdateRepository' is set
    if (
      createUpdateRepository === undefined ||
      createUpdateRepository === null
    ) {
      throw new Error(
        "Missing the required parameter 'createUpdateRepository' when calling createRepository"
      );
    }

    let pathParams = {};
    let queryParams = {};
    let headerParams = {};
    let formParams = {};

    let authNames = ["api_key"];
    let contentTypes = ["application/json"];
    let accepts = ["application/json"];
    let returnType = Repository;
    return this.apiClient.callApi(
      "/v1/repositories",
      "POST",
      pathParams,
      queryParams,
      headerParams,
      formParams,
      postBody,
      authNames,
      contentTypes,
      accepts,
      returnType,
      null
    );
  }

  /**
   * Create a new repository
   * @param {module:model/CreateUpdateRepository} createUpdateRepository
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Repository}
   */
  createRepository(createUpdateRepository) {
    return this.createRepositoryWithHttpInfo(createUpdateRepository).then(
      function (response_and_data) {
        return response_and_data.data;
      }
    );
  }

  /**
   * Create a new dataset within a repository
   * @param {String} repositoryUID
   * @param {String} xRepositoryKey The secret key used to access this repository
   * @param {module:model/DataSet} dataSet
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/DataSet} and HTTP response
   */
  createRepositoryDatasetWithHttpInfo(repositoryUID, xRepositoryKey, dataSet) {
    let postBody = dataSet;
    // verify the required parameter 'repositoryUID' is set
    if (repositoryUID === undefined || repositoryUID === null) {
      throw new Error(
        "Missing the required parameter 'repositoryUID' when calling createRepositoryDataset"
      );
    }
    // verify the required parameter 'xRepositoryKey' is set
    if (xRepositoryKey === undefined || xRepositoryKey === null) {
      throw new Error(
        "Missing the required parameter 'xRepositoryKey' when calling createRepositoryDataset"
      );
    }
    // verify the required parameter 'dataSet' is set
    if (dataSet === undefined || dataSet === null) {
      throw new Error(
        "Missing the required parameter 'dataSet' when calling createRepositoryDataset"
      );
    }

    let pathParams = {
      repositoryUID: repositoryUID,
    };
    let queryParams = {};
    let headerParams = {
      "X-Repository-Key": xRepositoryKey,
    };
    let formParams = {};

    let authNames = ["api_key"];
    let contentTypes = ["application/json"];
    let accepts = ["application/json"];
    let returnType = DataSet;
    return this.apiClient.callApi(
      "/v1/repositories/{repositoryUID}/datasets",
      "PUT",
      pathParams,
      queryParams,
      headerParams,
      formParams,
      postBody,
      authNames,
      contentTypes,
      accepts,
      returnType,
      null
    );
  }

  /**
   * Create a new dataset within a repository
   * @param {String} repositoryUID
   * @param {String} xRepositoryKey The secret key used to access this repository
   * @param {module:model/DataSet} dataSet
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/DataSet}
   */
  createRepositoryDataset(repositoryUID, xRepositoryKey, dataSet) {
    return this.createRepositoryDatasetWithHttpInfo(
      repositoryUID,
      xRepositoryKey,
      dataSet
    ).then(function (response_and_data) {
      return response_and_data.data;
    });
  }

  /**
   * Delete a repository
   * @param {String} repositoryUID
   * @param {String} xRepositoryKey The secret key used to access this repository
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
   */
  deleteRepositoryWithHttpInfo(repositoryUID, xRepositoryKey) {
    let postBody = null;
    // verify the required parameter 'repositoryUID' is set
    if (repositoryUID === undefined || repositoryUID === null) {
      throw new Error(
        "Missing the required parameter 'repositoryUID' when calling deleteRepository"
      );
    }
    // verify the required parameter 'xRepositoryKey' is set
    if (xRepositoryKey === undefined || xRepositoryKey === null) {
      throw new Error(
        "Missing the required parameter 'xRepositoryKey' when calling deleteRepository"
      );
    }

    let pathParams = {
      repositoryUID: repositoryUID,
    };
    let queryParams = {};
    let headerParams = {
      "X-Repository-Key": xRepositoryKey,
    };
    let formParams = {};

    let authNames = ["api_key"];
    let contentTypes = [];
    let accepts = ["application/json"];
    let returnType = null;
    return this.apiClient.callApi(
      "/v1/repositories/{repositoryUID}",
      "DELETE",
      pathParams,
      queryParams,
      headerParams,
      formParams,
      postBody,
      authNames,
      contentTypes,
      accepts,
      returnType,
      null
    );
  }

  /**
   * Delete a repository
   * @param {String} repositoryUID
   * @param {String} xRepositoryKey The secret key used to access this repository
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}
   */
  deleteRepository(repositoryUID, xRepositoryKey) {
    return this.deleteRepositoryWithHttpInfo(
      repositoryUID,
      xRepositoryKey
    ).then(function (response_and_data) {
      return response_and_data.data;
    });
  }

  /**
   * Delete a dataset
   * @param {String} repositoryUID
   * @param {String} name The name of the data set
   * @param {String} xRepositoryKey The secret key used to access this repository
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
   */
  deleteRepositoryDatasetWithHttpInfo(repositoryUID, name, xRepositoryKey) {
    let postBody = null;
    // verify the required parameter 'repositoryUID' is set
    if (repositoryUID === undefined || repositoryUID === null) {
      throw new Error(
        "Missing the required parameter 'repositoryUID' when calling deleteRepositoryDataset"
      );
    }
    // verify the required parameter 'name' is set
    if (name === undefined || name === null) {
      throw new Error(
        "Missing the required parameter 'name' when calling deleteRepositoryDataset"
      );
    }
    // verify the required parameter 'xRepositoryKey' is set
    if (xRepositoryKey === undefined || xRepositoryKey === null) {
      throw new Error(
        "Missing the required parameter 'xRepositoryKey' when calling deleteRepositoryDataset"
      );
    }

    let pathParams = {
      repositoryUID: repositoryUID,
      name: name,
    };
    let queryParams = {};
    let headerParams = {
      "X-Repository-Key": xRepositoryKey,
    };
    let formParams = {};

    let authNames = ["api_key"];
    let contentTypes = [];
    let accepts = ["application/json"];
    let returnType = null;
    return this.apiClient.callApi(
      "/v1/repositories/{repositoryUID}/datasets/{name}",
      "DELETE",
      pathParams,
      queryParams,
      headerParams,
      formParams,
      postBody,
      authNames,
      contentTypes,
      accepts,
      returnType,
      null
    );
  }

  /**
   * Delete a dataset
   * @param {String} repositoryUID
   * @param {String} name The name of the data set
   * @param {String} xRepositoryKey The secret key used to access this repository
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}
   */
  deleteRepositoryDataset(repositoryUID, name, xRepositoryKey) {
    return this.deleteRepositoryDatasetWithHttpInfo(
      repositoryUID,
      name,
      xRepositoryKey
    ).then(function (response_and_data) {
      return response_and_data.data;
    });
  }

  /**
   * Get repository information
   * @param {String} repositoryUID
   * @param {String} xRepositoryKey The secret key used to access this repository
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Repository} and HTTP response
   */
  getRepositoryWithHttpInfo(repositoryUID, xRepositoryKey) {
    let postBody = null;
    // verify the required parameter 'repositoryUID' is set
    if (repositoryUID === undefined || repositoryUID === null) {
      throw new Error(
        "Missing the required parameter 'repositoryUID' when calling getRepository"
      );
    }
    // verify the required parameter 'xRepositoryKey' is set
    if (xRepositoryKey === undefined || xRepositoryKey === null) {
      throw new Error(
        "Missing the required parameter 'xRepositoryKey' when calling getRepository"
      );
    }

    let pathParams = {
      repositoryUID: repositoryUID,
    };
    let queryParams = {};
    let headerParams = {
      "X-Repository-Key": xRepositoryKey,
    };
    let formParams = {};

    let authNames = ["api_key"];
    let contentTypes = [];
    let accepts = ["application/json"];
    let returnType = Repository;
    return this.apiClient.callApi(
      "/v1/repositories/{repositoryUID}",
      "GET",
      pathParams,
      queryParams,
      headerParams,
      formParams,
      postBody,
      authNames,
      contentTypes,
      accepts,
      returnType,
      null
    );
  }

  /**
   * Get repository information
   * @param {String} repositoryUID
   * @param {String} xRepositoryKey The secret key used to access this repository
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Repository}
   */
  getRepository(repositoryUID, xRepositoryKey) {
    return this.getRepositoryWithHttpInfo(repositoryUID, xRepositoryKey).then(
      function (response_and_data) {
        return response_and_data.data;
      }
    );
  }

  /**
   * Get event and session data from a repository in NDJSON format.
   * @param {String} xRepositoryKey The secret key used to access this repository
   * @param {String} repositoryUID
   * @param {String} start Start of the time range, as an ISO-8601 date or relative to now (e.g. -1y). Relative dates follow the Postgres INTERVAL format.
   * @param {Object} opts Optional parameters
   * @param {String} opts.end End of the time range, as an ISO-8601 date or relative to now. If omitted, current time is used.
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link File} and HTTP response
   */
  getRepositoryDataWithHttpInfo(xRepositoryKey, repositoryUID, start, opts) {
    opts = opts || {};
    let postBody = null;
    // verify the required parameter 'xRepositoryKey' is set
    if (xRepositoryKey === undefined || xRepositoryKey === null) {
      throw new Error(
        "Missing the required parameter 'xRepositoryKey' when calling getRepositoryData"
      );
    }
    // verify the required parameter 'repositoryUID' is set
    if (repositoryUID === undefined || repositoryUID === null) {
      throw new Error(
        "Missing the required parameter 'repositoryUID' when calling getRepositoryData"
      );
    }
    // verify the required parameter 'start' is set
    if (start === undefined || start === null) {
      throw new Error(
        "Missing the required parameter 'start' when calling getRepositoryData"
      );
    }

    let pathParams = {
      repositoryUID: repositoryUID,
    };
    let queryParams = {
      start: start,
      end: opts["end"],
    };
    let headerParams = {
      "X-Repository-Key": xRepositoryKey,
    };
    let formParams = {};

    let authNames = ["api_key"];
    let contentTypes = [];
    let accepts = ["text/csv", "application/json"];
    let returnType = File;
    return this.apiClient.callApi(
      "/v1/repositories/{repositoryUID}/data",
      "GET",
      pathParams,
      queryParams,
      headerParams,
      formParams,
      postBody,
      authNames,
      contentTypes,
      accepts,
      returnType,
      null
    );
  }

  /**
   * Get event and session data from a repository in NDJSON format.
   * @param {String} xRepositoryKey The secret key used to access this repository
   * @param {String} repositoryUID
   * @param {String} start Start of the time range, as an ISO-8601 date or relative to now (e.g. -1y). Relative dates follow the Postgres INTERVAL format.
   * @param {Object} opts Optional parameters
   * @param {String} opts.end End of the time range, as an ISO-8601 date or relative to now. If omitted, current time is used.
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link File}
   */
  getRepositoryData(xRepositoryKey, repositoryUID, start, opts) {
    return this.getRepositoryDataWithHttpInfo(
      xRepositoryKey,
      repositoryUID,
      start,
      opts
    ).then(function (response_and_data) {
      return response_and_data.data;
    });
  }

  /**
   * Get the details of a dataset
   * @param {String} repositoryUID
   * @param {String} name The name of the data set
   * @param {String} xRepositoryKey The secret key used to access this repository
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/DataSet} and HTTP response
   */
  getRepositoryDatasetWithHttpInfo(repositoryUID, name, xRepositoryKey) {
    let postBody = null;
    // verify the required parameter 'repositoryUID' is set
    if (repositoryUID === undefined || repositoryUID === null) {
      throw new Error(
        "Missing the required parameter 'repositoryUID' when calling getRepositoryDataset"
      );
    }
    // verify the required parameter 'name' is set
    if (name === undefined || name === null) {
      throw new Error(
        "Missing the required parameter 'name' when calling getRepositoryDataset"
      );
    }
    // verify the required parameter 'xRepositoryKey' is set
    if (xRepositoryKey === undefined || xRepositoryKey === null) {
      throw new Error(
        "Missing the required parameter 'xRepositoryKey' when calling getRepositoryDataset"
      );
    }

    let pathParams = {
      repositoryUID: repositoryUID,
      name: name,
    };
    let queryParams = {};
    let headerParams = {
      "X-Repository-Key": xRepositoryKey,
    };
    let formParams = {};

    let authNames = ["api_key"];
    let contentTypes = [];
    let accepts = ["application/json"];
    let returnType = DataSet;
    return this.apiClient.callApi(
      "/v1/repositories/{repositoryUID}/datasets/{name}",
      "GET",
      pathParams,
      queryParams,
      headerParams,
      formParams,
      postBody,
      authNames,
      contentTypes,
      accepts,
      returnType,
      null
    );
  }

  /**
   * Get the details of a dataset
   * @param {String} repositoryUID
   * @param {String} name The name of the data set
   * @param {String} xRepositoryKey The secret key used to access this repository
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/DataSet}
   */
  getRepositoryDataset(repositoryUID, name, xRepositoryKey) {
    return this.getRepositoryDatasetWithHttpInfo(
      repositoryUID,
      name,
      xRepositoryKey
    ).then(function (response_and_data) {
      return response_and_data.data;
    });
  }

  /**
   * Update a repository
   * @param {String} repositoryUID
   * @param {String} xRepositoryKey The secret key used to access this repository
   * @param {module:model/CreateUpdateRepository} createUpdateRepository
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/Repository} and HTTP response
   */
  putRepositoryWithHttpInfo(
    repositoryUID,
    xRepositoryKey,
    createUpdateRepository
  ) {
    let postBody = createUpdateRepository;
    // verify the required parameter 'repositoryUID' is set
    if (repositoryUID === undefined || repositoryUID === null) {
      throw new Error(
        "Missing the required parameter 'repositoryUID' when calling putRepository"
      );
    }
    // verify the required parameter 'xRepositoryKey' is set
    if (xRepositoryKey === undefined || xRepositoryKey === null) {
      throw new Error(
        "Missing the required parameter 'xRepositoryKey' when calling putRepository"
      );
    }
    // verify the required parameter 'createUpdateRepository' is set
    if (
      createUpdateRepository === undefined ||
      createUpdateRepository === null
    ) {
      throw new Error(
        "Missing the required parameter 'createUpdateRepository' when calling putRepository"
      );
    }

    let pathParams = {
      repositoryUID: repositoryUID,
    };
    let queryParams = {};
    let headerParams = {
      "X-Repository-Key": xRepositoryKey,
    };
    let formParams = {};

    let authNames = ["api_key"];
    let contentTypes = ["application/json"];
    let accepts = ["application/json"];
    let returnType = Repository;
    return this.apiClient.callApi(
      "/v1/repositories/{repositoryUID}",
      "PUT",
      pathParams,
      queryParams,
      headerParams,
      formParams,
      postBody,
      authNames,
      contentTypes,
      accepts,
      returnType,
      null
    );
  }

  /**
   * Update a repository
   * @param {String} repositoryUID
   * @param {String} xRepositoryKey The secret key used to access this repository
   * @param {module:model/CreateUpdateRepository} createUpdateRepository
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/Repository}
   */
  putRepository(repositoryUID, xRepositoryKey, createUpdateRepository) {
    return this.putRepositoryWithHttpInfo(
      repositoryUID,
      xRepositoryKey,
      createUpdateRepository
    ).then(function (response_and_data) {
      return response_and_data.data;
    });
  }

  /**
   * Query a dataset with support for time ranges, field selection, filtering, and location-based queries
   * @param {String} xRepositoryKey The secret key used to access this repository
   * @param {String} repositoryUID
   * @param {String} name The name of the data set
   * @param {String} start Start of the time range, as an ISO-8601 date or relative to now (e.g. -1y). Relative dates follow the Postgres INTERVAL format.
   * @param {Object} opts Optional parameters
   * @param {String} opts.end End of the time range, as an ISO-8601 date or relative to now. If omitted, current time is used.
   * @param {String} opts.select Comma separated list of fields to include. Supports aggregate functions (avg, sum, min, max, count, most_recent).
   * @param {String} opts.where Additional filters using boolean logic mini-language (e.g. and.(device.eq.dev:123,temp.gt.100))
   * @param {String} opts.aggregateWindow Aggregate results into buckets for a time duration, expressed in Postgres INTERVAL format
   * @param {String} opts.locationNear Latitude and Longitude for location-based filtering, location_near_radius must also be provided
   * @param {Number} opts.locationNearRadius Distance from location_near in meters, location_near must also be provided
   * @param {Number} opts.limit Limit the number of results returned
   * @param {String} opts.orderBy Order the results by a field
   * @param {Boolean} opts.distinct Return only distinct results
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link File} and HTTP response
   */
  queryRepositoryDatasetWithHttpInfo(
    xRepositoryKey,
    repositoryUID,
    name,
    start,
    opts
  ) {
    opts = opts || {};
    let postBody = null;
    // verify the required parameter 'xRepositoryKey' is set
    if (xRepositoryKey === undefined || xRepositoryKey === null) {
      throw new Error(
        "Missing the required parameter 'xRepositoryKey' when calling queryRepositoryDataset"
      );
    }
    // verify the required parameter 'repositoryUID' is set
    if (repositoryUID === undefined || repositoryUID === null) {
      throw new Error(
        "Missing the required parameter 'repositoryUID' when calling queryRepositoryDataset"
      );
    }
    // verify the required parameter 'name' is set
    if (name === undefined || name === null) {
      throw new Error(
        "Missing the required parameter 'name' when calling queryRepositoryDataset"
      );
    }
    // verify the required parameter 'start' is set
    if (start === undefined || start === null) {
      throw new Error(
        "Missing the required parameter 'start' when calling queryRepositoryDataset"
      );
    }

    let pathParams = {
      repositoryUID: repositoryUID,
      name: name,
    };
    let queryParams = {
      start: start,
      end: opts["end"],
      select: opts["select"],
      where: opts["where"],
      aggregate_window: opts["aggregateWindow"],
      location_near: opts["locationNear"],
      location_near_radius: opts["locationNearRadius"],
      limit: opts["limit"],
      order_by: opts["orderBy"],
      distinct: opts["distinct"],
    };
    let headerParams = {
      "X-Repository-Key": xRepositoryKey,
    };
    let formParams = {};

    let authNames = ["api_key"];
    let contentTypes = [];
    let accepts = ["text/csv", "application/json"];
    let returnType = File;
    return this.apiClient.callApi(
      "/v1/repositories/{repositoryUID}/datasets/{name}/query",
      "GET",
      pathParams,
      queryParams,
      headerParams,
      formParams,
      postBody,
      authNames,
      contentTypes,
      accepts,
      returnType,
      null
    );
  }

  /**
   * Query a dataset with support for time ranges, field selection, filtering, and location-based queries
   * @param {String} xRepositoryKey The secret key used to access this repository
   * @param {String} repositoryUID
   * @param {String} name The name of the data set
   * @param {String} start Start of the time range, as an ISO-8601 date or relative to now (e.g. -1y). Relative dates follow the Postgres INTERVAL format.
   * @param {Object} opts Optional parameters
   * @param {String} opts.end End of the time range, as an ISO-8601 date or relative to now. If omitted, current time is used.
   * @param {String} opts.select Comma separated list of fields to include. Supports aggregate functions (avg, sum, min, max, count, most_recent).
   * @param {String} opts.where Additional filters using boolean logic mini-language (e.g. and.(device.eq.dev:123,temp.gt.100))
   * @param {String} opts.aggregateWindow Aggregate results into buckets for a time duration, expressed in Postgres INTERVAL format
   * @param {String} opts.locationNear Latitude and Longitude for location-based filtering, location_near_radius must also be provided
   * @param {Number} opts.locationNearRadius Distance from location_near in meters, location_near must also be provided
   * @param {Number} opts.limit Limit the number of results returned
   * @param {String} opts.orderBy Order the results by a field
   * @param {Boolean} opts.distinct Return only distinct results
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link File}
   */
  queryRepositoryDataset(xRepositoryKey, repositoryUID, name, start, opts) {
    return this.queryRepositoryDatasetWithHttpInfo(
      xRepositoryKey,
      repositoryUID,
      name,
      start,
      opts
    ).then(function (response_and_data) {
      return response_and_data.data;
    });
  }

  /**
   * Run a raw Clickhouse-compatible SQL statement against the repository's database. Results are returned in CSV format
   * @param {String} repositoryUID
   * @param {String} xRepositoryKey The secret key used to access this repository
   * @param {String} body Clickhouse-compatible SQL statement
   * @param {Object} opts Optional parameters
   * @param {String} opts.xClickHouseFormat Specify the format of the response data. This functions the same as the ClickHouse `FORMAT` clause. Supported values include `CSV`, `JSON`, `JSONEachRow`, `TabSeparated`, and `NDJSON`. If not specified, defaults to `TabSeparated`.
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link File} and HTTP response
   */
  queryRepositorySqlWithHttpInfo(repositoryUID, xRepositoryKey, body, opts) {
    opts = opts || {};
    let postBody = body;
    // verify the required parameter 'repositoryUID' is set
    if (repositoryUID === undefined || repositoryUID === null) {
      throw new Error(
        "Missing the required parameter 'repositoryUID' when calling queryRepositorySql"
      );
    }
    // verify the required parameter 'xRepositoryKey' is set
    if (xRepositoryKey === undefined || xRepositoryKey === null) {
      throw new Error(
        "Missing the required parameter 'xRepositoryKey' when calling queryRepositorySql"
      );
    }
    // verify the required parameter 'body' is set
    if (body === undefined || body === null) {
      throw new Error(
        "Missing the required parameter 'body' when calling queryRepositorySql"
      );
    }

    let pathParams = {
      repositoryUID: repositoryUID,
    };
    let queryParams = {};
    let headerParams = {
      "X-Repository-Key": xRepositoryKey,
      "X-ClickHouse-Format": opts["xClickHouseFormat"],
    };
    let formParams = {};

    let authNames = ["api_key"];
    let contentTypes = ["text/plain"];
    let accepts = ["text/plain", "application/json"];
    let returnType = File;
    return this.apiClient.callApi(
      "/v1/repositories/{repositoryUID}/sql",
      "POST",
      pathParams,
      queryParams,
      headerParams,
      formParams,
      postBody,
      authNames,
      contentTypes,
      accepts,
      returnType,
      null
    );
  }

  /**
   * Run a raw Clickhouse-compatible SQL statement against the repository's database. Results are returned in CSV format
   * @param {String} repositoryUID
   * @param {String} xRepositoryKey The secret key used to access this repository
   * @param {String} body Clickhouse-compatible SQL statement
   * @param {Object} opts Optional parameters
   * @param {String} opts.xClickHouseFormat Specify the format of the response data. This functions the same as the ClickHouse `FORMAT` clause. Supported values include `CSV`, `JSON`, `JSONEachRow`, `TabSeparated`, and `NDJSON`. If not specified, defaults to `TabSeparated`.
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link File}
   */
  queryRepositorySql(repositoryUID, xRepositoryKey, body, opts) {
    return this.queryRepositorySqlWithHttpInfo(
      repositoryUID,
      xRepositoryKey,
      body,
      opts
    ).then(function (response_and_data) {
      return response_and_data.data;
    });
  }
}
