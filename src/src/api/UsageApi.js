/**
 * Notehub API
 * The OpenAPI definition for the Notehub.io API.
 *
 * The version of the OpenAPI document: 1.2.0
 * Contact: engineering@blues.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from "../ApiClient";
import Error from "../model/Error";
import GetDataUsage200Response from "../model/GetDataUsage200Response";
import GetSessionsUsage200Response from "../model/GetSessionsUsage200Response";
import UsageEventsResponse from "../model/UsageEventsResponse";

/**
 * Usage service.
 * @module api/UsageApi
 * @version 2.2.1
 */
export default class UsageApi {
  /**
   * Constructs a new UsageApi.
   * @alias module:api/UsageApi
   * @class
   * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
   * default to {@link module:ApiClient#instance} if unspecified.
   */
  constructor(apiClient) {
    this.apiClient = apiClient || ApiClient.instance;
  }

  /**
   * Get data usage in bytes for a project with time range and period aggregation
   * @param {String} projectOrProductUID
   * @param {module:model/String} period Period type for aggregation
   * @param {Object} opts Optional parameters
   * @param {Number} opts.startDate Start date for filtering results, specified as a Unix timestamp
   * @param {Number} opts.endDate End date for filtering results, specified as a Unix timestamp
   * @param {Array.<String>} opts.deviceUID A Device UID.
   * @param {module:model/String} opts.aggregate Aggregation level for results (default to 'device')
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/GetDataUsage200Response} and HTTP response
   */
  getDataUsageWithHttpInfo(projectOrProductUID, period, opts) {
    opts = opts || {};
    let postBody = null;
    // verify the required parameter 'projectOrProductUID' is set
    if (projectOrProductUID === undefined || projectOrProductUID === null) {
      throw new Error(
        "Missing the required parameter 'projectOrProductUID' when calling getDataUsage"
      );
    }
    // verify the required parameter 'period' is set
    if (period === undefined || period === null) {
      throw new Error(
        "Missing the required parameter 'period' when calling getDataUsage"
      );
    }

    let pathParams = {
      projectOrProductUID: projectOrProductUID,
    };
    let queryParams = {
      startDate: opts["startDate"],
      endDate: opts["endDate"],
      deviceUID: this.apiClient.buildCollectionParam(
        opts["deviceUID"],
        "multi"
      ),
      period: period,
      aggregate: opts["aggregate"],
    };
    let headerParams = {};
    let formParams = {};

    let authNames = ["personalAccessToken"];
    let contentTypes = [];
    let accepts = ["application/json"];
    let returnType = GetDataUsage200Response;
    return this.apiClient.callApi(
      "/v1/projects/{projectOrProductUID}/usage/data",
      "GET",
      pathParams,
      queryParams,
      headerParams,
      formParams,
      postBody,
      authNames,
      contentTypes,
      accepts,
      returnType,
      null
    );
  }

  /**
   * Get data usage in bytes for a project with time range and period aggregation
   * @param {String} projectOrProductUID
   * @param {module:model/String} period Period type for aggregation
   * @param {Object} opts Optional parameters
   * @param {Number} opts.startDate Start date for filtering results, specified as a Unix timestamp
   * @param {Number} opts.endDate End date for filtering results, specified as a Unix timestamp
   * @param {Array.<String>} opts.deviceUID A Device UID.
   * @param {module:model/String} opts.aggregate Aggregation level for results (default to 'device')
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/GetDataUsage200Response}
   */
  getDataUsage(projectOrProductUID, period, opts) {
    return this.getDataUsageWithHttpInfo(
      projectOrProductUID,
      period,
      opts
    ).then(function (response_and_data) {
      return response_and_data.data;
    });
  }

  /**
   * Get events usage for a project with time range and period aggregation, when endDate is 0 or unspecified the current time is implied
   * @param {String} projectOrProductUID
   * @param {module:model/String} period Period type for aggregation
   * @param {Object} opts Optional parameters
   * @param {Number} opts.startDate Start date for filtering results, specified as a Unix timestamp
   * @param {Number} opts.endDate End date for filtering results, specified as a Unix timestamp
   * @param {Array.<String>} opts.deviceUID A Device UID.
   * @param {module:model/String} opts.aggregate Aggregation level for results (default to 'device')
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/UsageEventsResponse} and HTTP response
   */
  getEventsUsageWithHttpInfo(projectOrProductUID, period, opts) {
    opts = opts || {};
    let postBody = null;
    // verify the required parameter 'projectOrProductUID' is set
    if (projectOrProductUID === undefined || projectOrProductUID === null) {
      throw new Error(
        "Missing the required parameter 'projectOrProductUID' when calling getEventsUsage"
      );
    }
    // verify the required parameter 'period' is set
    if (period === undefined || period === null) {
      throw new Error(
        "Missing the required parameter 'period' when calling getEventsUsage"
      );
    }

    let pathParams = {
      projectOrProductUID: projectOrProductUID,
    };
    let queryParams = {
      startDate: opts["startDate"],
      endDate: opts["endDate"],
      deviceUID: this.apiClient.buildCollectionParam(
        opts["deviceUID"],
        "multi"
      ),
      period: period,
      aggregate: opts["aggregate"],
    };
    let headerParams = {};
    let formParams = {};

    let authNames = ["personalAccessToken"];
    let contentTypes = [];
    let accepts = ["application/json"];
    let returnType = UsageEventsResponse;
    return this.apiClient.callApi(
      "/v1/projects/{projectOrProductUID}/usage/events",
      "GET",
      pathParams,
      queryParams,
      headerParams,
      formParams,
      postBody,
      authNames,
      contentTypes,
      accepts,
      returnType,
      null
    );
  }

  /**
   * Get events usage for a project with time range and period aggregation, when endDate is 0 or unspecified the current time is implied
   * @param {String} projectOrProductUID
   * @param {module:model/String} period Period type for aggregation
   * @param {Object} opts Optional parameters
   * @param {Number} opts.startDate Start date for filtering results, specified as a Unix timestamp
   * @param {Number} opts.endDate End date for filtering results, specified as a Unix timestamp
   * @param {Array.<String>} opts.deviceUID A Device UID.
   * @param {module:model/String} opts.aggregate Aggregation level for results (default to 'device')
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/UsageEventsResponse}
   */
  getEventsUsage(projectOrProductUID, period, opts) {
    return this.getEventsUsageWithHttpInfo(
      projectOrProductUID,
      period,
      opts
    ).then(function (response_and_data) {
      return response_and_data.data;
    });
  }

  /**
   * Get sessions usage for a project with time range and period aggregation, when endDate is 0 or unspecified the current time is implied
   * @param {String} projectOrProductUID
   * @param {module:model/String} period Period type for aggregation
   * @param {Object} opts Optional parameters
   * @param {Number} opts.startDate Start date for filtering results, specified as a Unix timestamp
   * @param {Number} opts.endDate End date for filtering results, specified as a Unix timestamp
   * @param {Array.<String>} opts.deviceUID A Device UID.
   * @param {module:model/String} opts.aggregate Aggregation level for results (default to 'device')
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/GetSessionsUsage200Response} and HTTP response
   */
  getSessionsUsageWithHttpInfo(projectOrProductUID, period, opts) {
    opts = opts || {};
    let postBody = null;
    // verify the required parameter 'projectOrProductUID' is set
    if (projectOrProductUID === undefined || projectOrProductUID === null) {
      throw new Error(
        "Missing the required parameter 'projectOrProductUID' when calling getSessionsUsage"
      );
    }
    // verify the required parameter 'period' is set
    if (period === undefined || period === null) {
      throw new Error(
        "Missing the required parameter 'period' when calling getSessionsUsage"
      );
    }

    let pathParams = {
      projectOrProductUID: projectOrProductUID,
    };
    let queryParams = {
      startDate: opts["startDate"],
      endDate: opts["endDate"],
      deviceUID: this.apiClient.buildCollectionParam(
        opts["deviceUID"],
        "multi"
      ),
      period: period,
      aggregate: opts["aggregate"],
    };
    let headerParams = {};
    let formParams = {};

    let authNames = ["personalAccessToken"];
    let contentTypes = [];
    let accepts = ["application/json"];
    let returnType = GetSessionsUsage200Response;
    return this.apiClient.callApi(
      "/v1/projects/{projectOrProductUID}/usage/sessions",
      "GET",
      pathParams,
      queryParams,
      headerParams,
      formParams,
      postBody,
      authNames,
      contentTypes,
      accepts,
      returnType,
      null
    );
  }

  /**
   * Get sessions usage for a project with time range and period aggregation, when endDate is 0 or unspecified the current time is implied
   * @param {String} projectOrProductUID
   * @param {module:model/String} period Period type for aggregation
   * @param {Object} opts Optional parameters
   * @param {Number} opts.startDate Start date for filtering results, specified as a Unix timestamp
   * @param {Number} opts.endDate End date for filtering results, specified as a Unix timestamp
   * @param {Array.<String>} opts.deviceUID A Device UID.
   * @param {module:model/String} opts.aggregate Aggregation level for results (default to 'device')
   * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/GetSessionsUsage200Response}
   */
  getSessionsUsage(projectOrProductUID, period, opts) {
    return this.getSessionsUsageWithHttpInfo(
      projectOrProductUID,
      period,
      opts
    ).then(function (response_and_data) {
      return response_and_data.data;
    });
  }
}
